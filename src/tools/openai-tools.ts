import axios from "axios";
import { User } from "../models/user.model"; // Modelo para los usuarios
import { DynamicRecord } from "../models/record.model";
import geolib from "geolib"; // Biblioteca para calcular distancias

export const get_start_dates = async (requestedDate = null, isGenericRequest = false) => {
  try {
    // Configuraci√≥n de la petici√≥n al API
    let config = {
      method: "get",
      maxBodyLength: Infinity,
      url: "http://localhost:10000/api/v1/datecourses",
      headers: {},
    };

    // Petici√≥n al API
    const response = await axios.request(config);

    // Obtener la fecha de hoy
    const today = new Date();

    // Filtrar solo los cursos de "Semana 1" que sean futuros
    let startCourses = response.data.dateCourses
      .filter((course: any) => course.type === 1 && new Date(course.date) >= today)
      .map((course: any) => new Date(course.date)) // Convertimos las fechas a objetos Date
      .sort((a: any, b: any) => a - b); // Ordenamos las fechas de menor a mayor

    if (startCourses.length === 0) {
      return "No hay semanas de inicio de curso programadas en las pr√≥ximas fechas.";
    }

    // Agrupar por semanas exactas de inicio
    let weeks: any = [];
    let currentWeek: any = [];

    startCourses.forEach((date: any, index: any) => {
      if (currentWeek.length === 0) {
        currentWeek.push(date);
      } else {
        let lastDate = currentWeek[currentWeek.length - 1];
        let diffDays = (date - lastDate) / (1000 * 60 * 60 * 24); // Diferencia en d√≠as

        if (diffDays === 1) {
          currentWeek.push(date);
        } else {
          weeks.push([...currentWeek]); // Guardamos la semana anterior
          currentWeek = [date]; // Empezamos una nueva semana
        }
      }

      // Agregar la √∫ltima semana acumulada
      if (index === startCourses.length - 1) {
        weeks.push([...currentWeek]);
      }
    });

    // **1. Si es una consulta gen√©rica (Ej: "¬øQu√© otras fechas tienes?")**
    if (isGenericRequest) {
      return "üì¢ ¬øPara qu√© fecha te gustar√≠a empezar? Puedo revisar las semanas disponibles a partir de ese mes o d√≠a espec√≠fico. üòä";
    }

    // **2. Si el cliente NO ha solicitado una fecha espec√≠fica, mostrar solo la PR√ìXIMA semana**
    if (!requestedDate) {
      const firstWeek = weeks[0];
      const start = firstWeek[0].toLocaleDateString("es-ES");
      const end = firstWeek[firstWeek.length - 1].toLocaleDateString("es-ES");

      return `üì¢ ¬°Tenemos cupo disponible para la pr√≥xima semana de inicio de curso!\nüìÖ *${start} - ${end}*\n\nüéØ No pierdas la oportunidad de empezar tu aprendizaje cuanto antes. ¬øTe gustar√≠a que te ayude con tu inscripci√≥n ahora mismo?`;
    }

    // **3. Si el cliente proporciona una fecha, mostrar semanas despu√©s de esa fecha**
    let requestedDateObj = new Date(requestedDate);
    let filteredWeeks = weeks.filter((week: any) => week[0] >= requestedDateObj);

    if (filteredWeeks.length === 0) {
      return "No hay semanas de inicio disponibles despu√©s de la fecha indicada.";
    }

    let message = "Estas son las pr√≥ximas semanas de inicio de curso disponibles:\n";
    filteredWeeks.forEach((week: any) => {
      const start = week[0].toLocaleDateString("es-ES");
      const end = week[week.length - 1].toLocaleDateString("es-ES");
      message += `üìÖ ${start} - ${end}\n`;
    });

    return `${message}\nüì¢ ¬°Aprovecha tu lugar antes de que se agoten los cupos! ¬øTe ayudo a asegurar tu inscripci√≥n ahora mismo?`;
  } catch (error) {
    if (error instanceof Error) {
      console.error("Error al obtener las semanas de inicio de cursos:", error.message);
    } else {
      console.error("Error al obtener las semanas de inicio de cursos:", error);
    }
    return "No pude obtener la informaci√≥n de inicio de cursos en este momento. Int√©ntalo m√°s tarde.";
  }
};

export const register_user_name = async (full_name: string, WaId: string): Promise<string> => {
  try {
    // Obtener todos los usuarios disponibles
    const users = await User.find();
    if (users.length === 0) {
      throw new Error("No hay usuarios disponibles para asignar.");
    }

    // Seleccionar un usuario aleatorio
    const agentIndex = Math.floor(Math.random() * users.length);
    const agent = users[agentIndex];

    // Actualizar el cliente en la tabla de prospectos
    const updatedCustomer = await DynamicRecord.findOneAndUpdate(
      {
        tableSlug: "prospectos", // Asegurarse de que el registro pertenece a la tabla "prospectos"
        customFields: { $elemMatch: { key: "phone", value: WaId } }, // Buscar por el n√∫mero de tel√©fono
      },
      {
        $set: {
          "customFields.$[nameField].value": full_name,
          "customFields.$[statusField].value": "Interesado",
          "customFields.$[classificationField].value": "Prospecto",
          "customFields.$[userField].value": JSON.stringify({ name: agent.name, _id: agent._id }), // Asignar el usuario con el formato requerido
          "customFields.$[aiField].value": false,
        },
      },
      {
        arrayFilters: [
          { "nameField.key": "name" },
          { "statusField.key": "status" },
          { "classificationField.key": "classification" },
          { "userField.key": "user" },
          { "aiField.key": "ai" },
        ],
        new: true, // Retornar el documento actualizado
      }
    );

    if (!updatedCustomer) {
      throw new Error("No se encontr√≥ el cliente en la tabla de prospectos.");
    }

    console.log("‚úÖ Cliente actualizado exitosamente:", updatedCustomer);

    return `¬°Gracias, ${full_name}! Ahora que tengo tu nombre, puedo continuar con el proceso de inscripci√≥n. ¬øMe puedes proporcionar tu n√∫mero de contacto?`;
  } catch (error) {
    if (error instanceof Error) {
      console.error("‚ùå Error al registrar el nombre del usuario:", error.message);
    } else {
      console.error("‚ùå Error al registrar el nombre del usuario:", error);
    }
    return "Hubo un problema al registrar tu nombre. Por favor, int√©ntalo de nuevo m√°s tarde.";
  }
};

export const submit_student_complaint = async (issueDetails: string, WaId: string): Promise<string> => {
  try {
    // Obtener todos los usuarios disponibles
    const users = await User.find();
    if (users.length === 0) {
      throw new Error("No hay usuarios disponibles para asignar.");
    }

    // Seleccionar un usuario aleatorio
    const agentIndex = Math.floor(Math.random() * users.length);
    const agent = users[agentIndex];

    // Buscar al cliente en la tabla de prospectos
    const customer = await DynamicRecord.findOne({
      tableSlug: "prospectos",
      customFields: { $elemMatch: { key: "phone", value: WaId } },
    });

    if (!customer) {
      throw new Error("No se encontr√≥ el cliente en la tabla de prospectos.");
    }

    // Crear un nuevo registro en la tabla de problemas
    const newProblem = new DynamicRecord({
      tableSlug: "problemas", // Tabla de problemas
      customFields: [
        ...customer.customFields, // Copiar los datos del cliente
        { key: "issueDetails", label: "Detalles del Problema", value: issueDetails, type: "text" },
        { key: "status", label: "Estado", value: "Queja", type: "select" },
        { key: "classification", label: "Clasificaci√≥n", value: "Urgente", type: "select" },
        { key: "user", label: "Asesor Asignado", value: JSON.stringify({ name: agent.name, _id: agent._id }), type: "text" }, // Asignar el usuario con el formato requerido
        { key: "ai", label: "AI", value: false, type: "text" },
      ],
    });

    await newProblem.save();

    // Eliminar al cliente de la tabla de prospectos
    await DynamicRecord.deleteOne({
      tableSlug: "prospectos",
      customFields: { $elemMatch: { key: "phone", value: WaId } },
    });

    console.log("‚úÖ Cliente movido a la tabla de problemas y eliminado de prospectos.");

    return `‚ö†Ô∏è *Lamentamos escuchar esto.* Queremos ayudarte lo m√°s r√°pido posible. Para dar seguimiento a tu reporte, por favor env√≠anos la siguiente informaci√≥n:\n\nüìù *Nombre completo*\nüè´ *Sucursal donde est√°s inscrito*\nüìö *Curso que est√°s tomando*\n‚è∞ *Horario en el que asistes*\nüì¢ *Detalles del problema:* "${issueDetails}"\nüé´ *N√∫mero de alumno*\n\nCon esta informaci√≥n, nuestro equipo podr√° revisar tu caso y darte una soluci√≥n lo antes posible. ¬°Estamos para ayudarte! üòä`;
  } catch (error) {
    console.error("‚ùå Error al registrar la queja del cliente:", (error as any).message);
    return "Hubo un problema al registrar tu queja. Por favor, int√©ntalo de nuevo m√°s tarde.";
  }
};

export const suggest_branch_or_virtual_course = async (city: string, WaId: string): Promise<string> => {
  try {
    // Obtener las sedes desde la tabla "sedes"
    const branches = await DynamicRecord.find({
      tableSlug: "sedes",
      customFields: { $elemMatch: { key: "status", value: "activo" } },
    });

    if (!branches || branches.length === 0) {
      throw new Error("No se encontraron sedes activas.");
    }

    // Normalizar la ciudad para la b√∫squeda
    const normalizedCity = city.trim().toLowerCase();

    // Buscar una sede que coincida con la ciudad
    const foundBranch = branches.find((branch: any) => {
      const cityField = branch.customFields.find((field: any) => field.key === "Ciudad");
      return cityField && cityField.value.toLowerCase().includes(normalizedCity);
    });

    if (foundBranch) {
      const nameField = foundBranch.customFields.find((field: any) => field.key === "nombre");
      const locationField = foundBranch.customFields.find((field: any) => field.key === "ubicaci√≥n");
      const googleMapsField = foundBranch.customFields.find((field: any) => field.key === "link de googlemaps");

      return `üìç ¬°Qu√© bonito lugar! Tenemos una sucursal en tu ciudad:\n\nüè´ *${nameField?.value}*\nüìç Direcci√≥n: ${locationField?.value}\nüåê Google Maps: ${googleMapsField?.value}\n\n¬øC√≥mo te gustar√≠a aprender ingl√©s? Contamos con tres modalidades:\n\n1. Presencial ‚Äì Asistes f√≠sicamente a la escuela.\n2. Virtual (a distancia) ‚Äì Clases en vivo por videollamada.\n3. Online ‚Äì Plataforma autogestionada a tu ritmo, sin horarios.\n\n¬øCu√°l prefieres?`;
    } else {
      // Si no se encuentra una sucursal, asignar un asesor y desactivar la IA
      const users = await User.find();
      if (users.length === 0) {
        throw new Error("No hay usuarios disponibles para asignar.");
      }

      const agentIndex = Math.floor(Math.random() * users.length);
      const agent = users[agentIndex];

      await DynamicRecord.findOneAndUpdate(
        { tableSlug: "prospectos", customFields: { $elemMatch: { key: "phone", value: WaId } } },
        {
          $set: {
            "customFields.$[classificationField].value": "Prospecto",
            "customFields.$[statusField].value": "Interesado",
            "customFields.$[userField].value": JSON.stringify({ name: agent.name, _id: agent._id }), // Asignar el usuario con el formato requerido
            "customFields.$[aiField].value": false,
          },
        },
        {
          arrayFilters: [
            { "classificationField.key": "classification" },
            { "statusField.key": "status" },
            { "userField.key": "user" },
            { "aiField.key": "ai" },
          ],
          new: true,
        }
      );

      return `ü§ñ ¬°Qu√© padre, ${city} es un lugar hermoso! Actualmente no tenemos una sucursal presencial ah√≠, pero no te preocupes...\n\nüéØ Tenemos dos opciones incre√≠bles para ti:\n1. **Virtual** ‚Äì Clases en vivo por videollamada con maestros certificados.\n2. **Online** ‚Äì Aprende a tu propio ritmo con nuestra plataforma 24/7.\n\nüì≤ Ambas opciones son s√∫per efectivas y puedes tomarlas desde la comodidad de tu casa.\n\n¬øTe gustar√≠a que te cuente m√°s detalles para que elijas la que mejor se adapta a ti?`;
    }
  } catch (error) {
    console.error("Error al obtener sedes:", (error as any).message);
    return "No pude verificar las sedes en este momento, pero si me dices tu ciudad, puedo ayudarte manualmente.";
  }
};

export const suggest_nearby_branch = async (params: any, WaId: string): Promise<string> => {
  try {
    // Obtener las sedes activas desde la tabla "sedes"
    const branches = await DynamicRecord.find({
      tableSlug: "sedes",
      customFields: { $elemMatch: { key: "status", value: "activo" } },
    });

    if (!branches || branches.length === 0) {
      throw new Error("No se encontraron sedes activas.");
    }

    let userCoords;

    // üìç Si vienen coordenadas, las usamos directamente
    if (params.lat && params.lng) {
      userCoords = {
        latitude: parseFloat(params.lat),
        longitude: parseFloat(params.lng),
      };
    } else if (params.address) {
      // üó∫Ô∏è Si viene una direcci√≥n, la geocodificamos
      const geo = await axios.get("http://api.positionstack.com/v1/forward", {
        params: {
          access_key: process.env.POSITIONSTACK_API_KEY,
          query: params.address,
          limit: 1,
          country: "MX",
        },
      });

      if (!geo.data.data.length) {
        return "No pude encontrar tu ubicaci√≥n exacta. ¬øPuedes darme una direcci√≥n m√°s espec√≠fica?";
      }

      userCoords = {
        latitude: geo.data.data[0].latitude,
        longitude: geo.data.data[0].longitude,
      };
    } else {
      return "Necesito una direcci√≥n o ubicaci√≥n para poder ayudarte.";
    }

    // üåç Geolocalizar sucursales
    const branchesWithCoords = branches.map((branch: any) => {
      const locationField = branch.customFields.find((field: any) => field.key === "ubicaci√≥n");
      const latField = branch.customFields.find((field: any) => field.key === "lat");
      const lngField = branch.customFields.find((field: any) => field.key === "lng");

      if (locationField && latField && lngField) {
        return {
          ...branch,
          lat: parseFloat(latField.value),
          lng: parseFloat(lngField.value),
        };
      }
      return null;
    }).filter((branch: any) => branch !== null);

    const sedesConDistancia = branchesWithCoords.map((sede: any) => ({
      ...sede,
      distance: geolib.getDistance(userCoords, {
        latitude: sede.lat,
        longitude: sede.lng,
      }),
    }));

    const topSedes = sedesConDistancia
      .sort((a: any, b: any) => a.distance - b.distance)
      .slice(0, 3);

    if (topSedes.length > 0) {
      const lista = topSedes
        .map((s: any, i: number) => {
          const nameField = s.customFields.find((field: any) => field.key === "nombre");
          const locationField = s.customFields.find((field: any) => field.key === "ubicaci√≥n");
          return `*${i + 1}.* ${nameField?.value}\nüìç ${locationField?.value}`;
        })
        .join("\n\n");

      return `Estas son las sucursales m√°s cercanas a ti:\n\n${lista}\n\n¬øTe gustar√≠a que te d√© los horarios o modalidades que manejan en esta sucursal?`;
    } else {
      // Si no se encuentran sucursales cercanas, asignar un asesor y desactivar la IA
      const users = await User.find();
      if (users.length === 0) {
        throw new Error("No hay usuarios disponibles para asignar.");
      }

      const agentIndex = Math.floor(Math.random() * users.length);
      const agent = users[agentIndex];

      await DynamicRecord.findOneAndUpdate(
        { tableSlug: "prospectos", customFields: { $elemMatch: { key: "phone", value: WaId } } },
        {
          $set: {
            "customFields.$[classificationField].value": "Prospecto",
            "customFields.$[statusField].value": "Interesado",
            "customFields.$[userField].value": JSON.stringify({ name: agent.name, _id: agent._id }), // Asignar el usuario con el formato requerido
            "customFields.$[aiField].value": false,
          },
        },
        {
          arrayFilters: [
            { "classificationField.key": "classification" },
            { "statusField.key": "status" },
            { "userField.key": "user" },
            { "aiField.key": "ai" },
          ],
          new: true,
        }
      );

      return `üòï En esa ubicaci√≥n no encontr√© una sucursal presencial, pero *no te preocupes*. Tenemos cursos *virtuales* y *online* igual de efectivos que puedes tomar desde cualquier parte.\n\nüéØ Con clases en vivo, sesiones con maestros certificados y acceso 24/7, ¬°vas a avanzar rapid√≠simo! ¬øQuieres que te d√© los detalles para inscribirte?`;
    }
  } catch (error) {
    console.error("Error al obtener sucursales cercanas:", (error as any).message);
    return "No pude verificar las sucursales en este momento. ¬øPuedes decirme tu ciudad o direcci√≥n?";
  }
};
